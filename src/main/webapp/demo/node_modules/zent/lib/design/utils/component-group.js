'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createGroup = createGroup;
exports.isGroupComponent = isGroupComponent;
exports.isGrouped = isGrouped;
exports.splitGroup = splitGroup;

var _uniqueId = require('lodash/uniqueId');

var _uniqueId2 = _interopRequireDefault(_uniqueId);

var _startsWith = require('lodash/startsWith');

var _startsWith2 = _interopRequireDefault(_startsWith);

var _isEmpty = require('lodash/isEmpty');

var _isEmpty2 = _interopRequireDefault(_isEmpty);

var _designType = require('./design-type');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function DummyComponent() {
  return null;
}

function createGroup(name) {
  return {
    type: (0, _uniqueId2['default'])(_designType.COMPONENT_GROUP_DESIGN_TYPE) + '|' + name,
    editor: DummyComponent,
    preview: DummyComponent,
    name: name
  };
}

function isGroupComponent(component) {
  if (!component) {
    return false;
  }

  return (0, _startsWith2['default'])(component.type, _designType.COMPONENT_GROUP_DESIGN_TYPE);
}

/**
 * Check if component array is grouped.
 *
 * A grouped component array MUST have a group component as its first element.
 * @param {Array} components
 */
function isGrouped(components) {
  // Grouped components must have at least 2 elements
  if (!components || components.length < 2) {
    return false;
  }

  var possiblyGroup = components[0];
  return isGroupComponent(possiblyGroup);
}

/**
 * Split component array into an array of groups
 *
 * @param {Array} components
 */
function splitGroup(components) {
  if ((0, _isEmpty2['default'])(components)) {
    return [];
  }

  var lastIndex = components.length - 1;

  return components.reduce(function (state, c, idx) {
    var groups = state.groups,
        buffer = state.buffer,
        group = state.group;

    var isGroup = isGroupComponent(c);

    if (!isGroup) {
      buffer.push(c);
    }

    // When processing the last component, ensure buffer is consumed
    if (isGroup || idx === lastIndex) {
      // Empty group is ignored
      if (group && !(0, _isEmpty2['default'])(buffer)) {
        groups.push({
          group: group,
          components: buffer
        });
      }

      // Start a new group
      state.buffer = [];
      state.group = c;
    }

    return state;
  }, { groups: [], buffer: [], group: null }).groups;
}